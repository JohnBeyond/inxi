#!/usr/bin/env python

#    author: Scott Rogers
#    version: 2011.05.06
#    stability: pre-alpha
#    copying: 'Copyright (C) 2011 W. Scott Rogers
#              This program is free software.
#              You can redistribute it and/or modify it under the terms of the
#              GNU General Public License as published by the Free Software Foundation;
#              version 2 of the License.

import os
import sys
import optparse

def main(xiinArg):

    checkPython()

    xiinDesc = """ xiin is a directory parser meant to help debug inxi(www.inxi.org) bugs.
        xiin will take a given directory, usually /sys or /proc and write the contents
        to a specified file in key:value format where key is the directory/filename
        and value is the contents of key."""

    xiinUsage   = "%prog [-d] <directory to read> [-f] <file to write>"

    xiinVersion = "%prog 2011.05.06-alpha"

#    defaultFile = os.environ['HOME'] + '/xiin.txt'
#    defaultDir = '/sys'
#    defaultDisplay = False

    dirHelp     = 'directory containing files'
    fileHelp    = 'if used write report to file, otherwise write output to the screen'
    displayHelp = 'prints to terminal not to a file.  Cannot use with -f option'

    parser = optparse.OptionParser(description = xiinDesc, usage = xiinUsage, version = xiinVersion)

    parser.add_option('-d', '--directory', dest = 'directory', help = dirHelp)
    parser.add_option('-f', '--file', dest = 'filename', help = fileHelp)
    parser.add_option('-o', '--out', action = 'store_true', dest = 'display', help = displayHelp)

    (options, args) = parser.parse_args()
    if len(xiinArg) < 2:
        parser.error('Nothing to do. Try option -h or --help.')
        exit(2)
    elif options.directory is None:
        parser.error('xiin needs a directory')
        exit(3)
    elif options.filename is None and option.display is None:
        parser.error('specify a file or display outpu')
        exit(4)
    elif options.directory == '/proc':
        parser.error('xiin can not walk /proc')
        exit(5)
    else:
        print('Starting xiin...')
        print('')
        print('Using options: ' + str(options))
        print('')
        getInfo(options.display, options.filename, options.directory)
#end

def getInfo(display, xiinFile, inDir):
    """ Walks the directory reading file contents """
    print("Getting info")
    print('')

    spinner = [ '  \\  ', '  |  ', '  /  ', '  -  ']

    count = 1

    with open(xiinFile, 'w') as someOutput:
        for root, dirs, files in os.walk(inDir):
            for file in files:
                if int(count%25) > 4:
                    count = 1
                if (int(count%25) == 1) or (int(count%25) == 2) or (int(count%25) == 3) or (int(count%25) == 4):
                    print(spinner[count%25 - 1]),
                    sys.stdout.flush()
                    sys.stdout.write('\r')
                count = count + 1
                fullPathFile = os.path.join(root, file)
                try:
                    if os.stat(fullPathFile).st_size:
                        try:
                            with open(fullPathFile, 'r') as someFile:
                                try:
                                    contents = someFile.readlines()
                                    if display:
                                        print('file: ' + os.path.join(root, file) + ':' + str(contents) )
                                    else:
                                        someOutput.writelines('file: ' + os.path.join(root, file) + ':' + str(contents) + '\n' )                                        
                                except:
                                    pass
                        except IOError:
                            pass
                except:
                    pass
    exit(0)
#end

def checkPython():
    """ Detects Python compatibility.  Python 2.6+ required"""
    print('Detecting Python version...')
    print('')
    if sys.hexversion < 0x02060000:
        print('Incorrect Python version: 2.6+ is required')
        exit(1)
    else:
        return
#end

if __name__ == '__main__':
    main(sys.argv)
#end
